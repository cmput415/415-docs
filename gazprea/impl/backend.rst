Backend
=======

You donâ€™t need to implement an interpreter for Gazprea. You only need to
implement a llvm code generator.

.. _sec:memory:

Memory Management
-----------------

It is important that you are able to automatically free and allocate
memory for vectors and matrices when they enter and exit scope. You may
use ``malloc`` and ``free`` for these purposes. This will have to be
done within the LLVM IR, as your runtime will not be able to tell when
your variables should be freed.

Below is an example of how to use ``malloc`` and ``free`` within LLVM:

::

         define i32 @main(i32 %argc, i8** %argv) {
           %1 = call i8* @malloc(i64 128)
           call void @free(i8* %1)
           ret i32 0
         }

         declare i8* @malloc(i64)
         declare void @free(i8*)

It is important that the code generated by your compiler has no memory
leaks, and that all memory is freed as soon as possible.

Runtime Libraries
-----------------

If you make a runtime library, the runtime library must be implemented
in a runtime directory (lib). Beware that in C++ there is additional
name mangling that occurs to allow class functions. Thus, we recommend
that all runtime functions should be written in C and not in C++. There
is a Makefile in the (lib) folder designed to turn all ``*.c`` and
``*.h`` pairs into part of the unified runtime library ``libruntime.a``.
An example of how to make a runtime function is provided bellow.

``functions.c``

::

       #include "functions.h"

       uint64_t factorial(uint64_t n) {
           uint64_t fact = 1;

           while (n > 0) {
               fact *= n;
               n--;
           }

           return fact;
       }

``functions.h``

::

       #pragma once

       #include <stdint.h>

       uint64_t factorial(uint64_t n);

If ou compiler was compiling the following input ``Input file``

::

       3! + (2 + 7)!

Here is how to call the function in LLVM code.

``LLVM src``

::

       target triple = "x86_64-pc-linux-gnu"
       define i32 @main() {

           ; Calls factorial on 3 for the first part of expression
           %0 = call i64 @factorial(i64 3)

           ; Adds 2 and 7 together
           %1 = add i64 2, 7

           ; Calls factorial of (2 + 7)
           %2 = call i64 @factorial(i64 %1)

           ; Adds the results of 3! and (2 + 7)!
           %3 = add i64 %0, %2

           ; Done, return 0
           ret i32 0
       }

       ; This makes the function available for calling
       declare i64 @factorial(i64)

