\documentclass[../gazprea.tex]{subfiles}

\begin{document}
\textit{Gazprea} provides explicit type casting. A value may be converted to a different type using
the following syntax where \code{value} is an expression and \code{toType} is our destination type:
\begin{lstlisting}
  as<toType>(value)
\end{lstlisting}

Conversions from one type to another is not always legal. For instance converting from an
\code{integer} \code{matrix} to an \code{integer} has no reasonable conversion.

\subsection{Scalar to Scalar}
\label{ssec:typeCasting_stos}
This table summarizes all of the conversion rules between scalar types where N/A means no conversion
is possible, id means no change is necessary, and anything else describes how to convert the value
to the new type:
% Using \texttt here instead of \code because \code was causing line breaks in cells.
\begin{center}
\begin{tabular}{| c | c | c | c | c | c |}
  \hline
  \multicolumn{6}{c}{\textbf{To type}} \\ \hline
    && \multicolumn{1}{c}{boolean} & \multicolumn{1}{c}{character}
    & \multicolumn{1}{c}{integer} & \multicolumn{1}{c}{real} \\
    \cline{2-6}
  & boolean & id & `\textbackslash0' if false, 0x01 otherwise & 1 if true, 0 otherwise
    & 1.0 if true, 0.0 otherwise \\ \cline{2-6}
  \textbf{From} & character & false if `\textbackslash0', true otherwise & id
    & \textit{ASCII} value as integer & \textit{ASCII} value as real \\ \cline{2-6}
  \textbf{type} & integer & false if 0, true otherwise & unsigned integer value mod 256 & id
    & real version of integer \\ \cline{2-6}
  & real & N/A & N/A & truncate & id \\ \hline
\end{tabular}
\end{center}

\subsection{Scalar to Vector/Matrix}
\label{ssec:typecasting_stovm}
\label{ssec:typecasting_stov}
\label{ssec:typecasting_stom}
A scalar may be promoted to either a \code{vector} or \code{matrix} with an element type that the
original scalar can be cast to according to the rules in \nameref{ssec:typeCasting_stos}. A scalar
to vector cast \textit{must} include a size with the type to cast to as this cannot be inferred from
the scalar value. For example:
\begin{lstlisting}
  // Create a vector of reals with length three where all values are 1.0.
  real vector v = as<real vector[3]>(1);

  // Create a vector of booleans with length 10 where all values are true.
  var u = as<boolean vector[10]>('c');
\end{lstlisting}

\subsection{Interval to Vector}
\label{ssec:typeCasting_itov}
An \code{integer} \code{interval} may be explicitly cast to an \code{integer} or \code{real}
\code{vector} as in the \hyperref[ssec:typePromotion_ivltov]{type promotion rules}, but the explicit
cast can cause the interval to be truncated or \code{null} padded.

\subsection{Vector to Vector}
\label{ssec:typeCasting_vtov}
Conversions between \code{vector} types are also possible. First, the values of the original are
casted to the destination type's element type according to the rules in
\nameref{ssec:typeCasting_stos} and then the destination is padded with destination element type's
\code{null} or truncated to match the destination type size. Note that the size is not required for
vector to vector casting; if the size is not included in the cast type, the new size is assumed to
be the old size. For example:
\begin{lstlisting}
  real vector v[3] = [i in 1..3 | i + 0.3 * i];

  // Convert the real vector to an integer vector.
  integer vector u[3] = as<integer vector>(v);

  // Convert to integers and null pad.
  integer vector x[5] = as<integer[5]>(v);

  // Truncate the vector.
  real vector y[2] = as<real vector[2]>(v);
\end{lstlisting}

\subsection{Matrix to Matrix}
\label{ssec:typeCasting_mtom}
Conversions between \code{matrix} types are also possible. The process is exactly like
\nameref{ssec:typeCasting_vtov} except padding and truncation can occur in both dimensions. For
example:
\begin{lstlisting}
  real matrix a[2, 2] = [[1.2, 24], [-13e2, 4.0]];

  // Convert to an integer matrix.
  integer matrix b[2, 2] = as<integer matrix[2, 2]>(a);

  // Convert to integers and pad in both dimensions.
  integer matrix c[3, 3] = as<integer matrix[3, 3]>(a);

  // Truncate in one dimension and pad in the other.
  real matrix d[1, 3] = as<real matrix[1, 3]>(a);
  real matrix e[3, 1] = as<real matrix[3, 1]>(a);
\end{lstlisting}

\subsection{Tuple to Tuple}
\label{ssec:typeCasting_ttot}
Conversions between \code{tuple} types are also possible. The original type and the destination type
must have an equal number of internal types and each element must be pairwise castable according to
the rules in \nameref{ssec:typeCasting_stos}. For example:
\begin{lstlisting}
  tuple(integer, integer) int_tup = (1, 2);
  tuple(real, boolean) rb_tup = as<tuple(real, boolean)>(int_tup);
\end{lstlisting}

\end{document}
