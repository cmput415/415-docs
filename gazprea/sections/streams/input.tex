\documentclass[../gazprea.tex]{subfiles}

\begin{document}
Input streams use the following syntax:
\begin{lstlisting}
	<l-value> <- inp;
\end{lstlisting}

An l-value may be anything that can appear on the left hand side of an assignment statement.
Consider reading the discussion of an l-value
\href{https://en.wikipedia.org/wiki/Value_(computer_science)\#Assignment:_l-values_and_r-values}
{here}.

Input streams may only work on the following base types:
\begin{itemize}
	\item
    \code{character}: Reads a single character from stdin. Note that there can be no
    \hyperref[sssec:stream_error]{error state} for reading characters.
	\item \code{integer}:
    Reads an integer from stdin. If an integer could not be read, an \hyperref[sssec:stream_error]
    {error state} is set on this stream.
	\item \code{real}:
    Reads a real from stdin. If a real could not be read, an \hyperref[sssec:stream_error]{error
    state} is set on this stream.
	\item \code{boolean}:
    Reads a boolean from stdin. If a boolean value could not be read, an
    \hyperref[sssec:stream_error]{error state} is set on this stream.
\end{itemize}

\subsubsection{Input Format}
\label{sssec:input_format}
A \code{character} from stdin is the first byte that can be read from the stream. If the end of the
stream is encountered, then the ASCII EOF character is returned.

An \code{integer} from stdin can take any legal format described in the \hyperref[sssec:int_lit]
{integer literal} section. It may also be proceeded by a single negative or positive sign.

A \code{real} input from stdin can take any legal format described in the \hyperref[sssec:real_lit]
{real literal} section. It may also be proceeded by a single negative or positive sign.

A \code{boolean} input from stdin is either \code{T} or \code{F}.

Whitespace will separate values in stdin.

When reading a value, if any other input were to be in the stream during the read then an
\hyperref[sssec:stream_error]{error state} is set. For example, the following program:
\begin{lstlisting}
  boolean b;
  var stdin = std_input();
  b <- stdin;
\end{lstlisting}

With the standard input stream containing this:
\begin{lstlisting}
Ta
\end{lstlisting}

An \hyperref[sssec:stream_error]{error state} would be set on the stream.

% When reading anything else if something is read which does not match the data type (for instance if the letter
% 'a' is read while trying to parse an integer), then this is an error. In this case the value returned by the
% stream is \texttt{null}, and \texttt{stream\_state} should return 1. Or, if only whitespace and the end of the
% stream is encountered the stream is rewound to where it was before the read, \texttt{null} is returned, and
% \texttt{stream\_state} will return 2.

\subsubsection{Error Handling}
\label{sssec:stream_error}
When \code{boolean}s, \code{integer}s, and \code{real}s from stdin, it is possible that the end of
the stream or an error is encountered. In order to handle these situations \textit{Gazprea} provides
a built in procedure that is implicitly defined in every file:
\begin{lstlisting}
  procedure stream_state(var input_stream) returns integer;
\end{lstlisting}

This function can only be called with an input stream as a parameter. When called,
\code{stream\_state} will return an integer valued error code defined as follows:
\begin{itemize}
	\item \code{0}: Last read from the stream was successful.
	\item \code{1}: Last read from the stream encountered an error.
	\item \code{2}: Last read from the stream encountered the end of the stream.
\end{itemize}

When an error or end of stream is encountered the value returned is the type-appropriate
\code{null}.

\textbf{Under discussion}: When a read from the stream is not successful, and \code{stream\_state}
returns non-zero, then the stream must be rewound to where it was before the read started.

Reading a character can never cause an error. The character will either be successfully read or the
end of the stream will be reached and the character value \code{-1} will be returned on this and
subsequent reads.
\begin{center}
  \begin{tabular}{| c | c | c | c |}
    \hline
    Type & Situation & Return & \code{stream\_state}\\ \hline
    Boolean
      & error & \code{F} & 1 \\ \cline{2-4}
      & end of stream & \code{F} & 2 \\ \hline
    Character
      & error & N/A & N/A \\ \cline{2-4}
      & end of stream & \textbf{Under discussion:} \code{-1} & 0 \\ \hline
    Integer
      & error & \code{0} & 1 \\ \cline{2-4}
      & end of stream & \code{0} & 2 \\ \hline
    Real
      & error & \code{0.0} & 1 \\ \cline{2-4}
      & end of stream & \code{0.0} & 2 \\ \hline
  \end{tabular}
\end{center}

\end{document}
