\documentclass[types.tex]{subfiles}

\begin{document}
Intervals are a type used to represent ranges of values. \textit{Gazprea} only has support for
integer intervals.

\subsubsection{Declaration}
\label{sssec:inteval_decl}
Intervals are declared with the keyword \code{interval}. Only the \code{integer} base type for
intervals is supported by \textit{Gazprea}. For example:
\begin{lstlisting}
  integer interval iv;
\end{lstlisting}

\subsubsection{Null}
\label{sssec:interval_null}
\code{null} is defined as \code{null..null}. For the \code{integer} \code{interval} this is
\code{0..0}.

\subsubsection{Identity}
\label{sssec:interval_ident}
\code{identity} is defined as \code{identity..identity}. For the \code{integer} \code{interval} this
is \code{1..1}.

\subsubsection{Literals}
\label{sssec:interval_lit}
An \code{interval} literal is a range expression, created using two inclusive bounds and the range
operator (\code{..}). For example, a range from one to ten, including the endpoints:
\begin{lstlisting}
  integer interval i = 1..10;
\end{lstlisting}

\subsubsection{Operations}
\label{sssec:interval_ops}
Operations on intervals should follow the standard rules of
\href{http://en.wikipedia.org/wiki/Interval_arithmetic}{interval arithmetic}. In each case integer
operations should be used, for instance interval division should use integer division. For another
explanation see \href{http://www.csgnetwork.com/directintervalcalc.html}{this website} under the
heading of ``How the operations work''.

In the following table \code{ivl-expr} means any expression that yields an interval value and
\code{int-expr} means any integer yielding expression.

\begin{center}
\begin{tabular}{| c | l | c | l | c |}
  \hline
  \textbf{Class} & \multicolumn{1}{|c|}{\textbf{Operation}} & \textbf{Symbol} &
  \multicolumn{1}{|c|}{\textbf{Usage}} & \textbf{Associativity} \\
  \hline
  Arithmetic & addition           & \code{+}  & \code{ivl-expr + ivl-expr}  & left  \\
             & subtraction        & \code{-}  & \code{ivl-expr - ivl-expr}  & left  \\
             & multiplication     & \code{*}  & \code{ivl-expr * ivl-expr}  & left  \\
             & division           & \code{/}  & \code{ivl-expr / ivl-expr}  & left  \\
             & unary negation     & \code{-}  & \code{- ivl-expr}           & right \\
             & unary plus (no-op) & \code{+}  & \code{+ ivl-expr}           & right \\
  \hline
  Comparison & equals             & \code{==} & \code{ivl-expr == ivl-expr} & left  \\
             & not equals         & \code{!=} & \code{ivl-expr != ivl-expr} & left  \\
  \hline
  Vector     & vector creation    & \code{by} & \code{ivl-expr by int-expr} & left  \\
  \hline
\end{tabular}
\end{center}

Regarding the semantics of some of the operators:
\begin{itemize}
  \item Interval comparison checks the bounds of the interval.
  \item Range upper bounds must greater than or equal to the lower bound.
  \item Both bounds must be integer valued.
\end{itemize}

The precedence and associativity follows that of \hyperref[sssec:integer_ops]{integer operations}
for the operators defined in the above table, with the addition of the \code{by} and \code{..}
operators, in the following table. The \code{.} and \code{[]} operators are included for
clarification but for the full table see \nameref{ssec:operators}.

\begin{center}
\begin{tabular}{| c | c |}
  \hline
  \textbf{Precedence} & \textbf{Operations} \\
  \hline
  HIGHER & \code{.}       \\
         & \code{[]}      \\ \cline{2-2}
         & \code{..}      \\ \cline{2-2}
         & arithmetic ops \\ \cline{2-2}
         & \code{by}      \\ \cline{2-2}
  LOWER  & comparison ops \\
  \hline
\end{tabular}
\end{center}

This means that \code{by} is the lowest priority and so last binding operator, therefore each side
of the expression will be evaluated before evaluating the \code{by} operator. As well, \code{..} is
the highest priority and first binding operator, excluding the \code{.} and \code{[]} operators
which create atoms, and will bind to atoms before other operators. For example:
\begin{lstlisting}
  1 .. 10 by 3
  a[1] .. b.3 by 3
\end{lstlisting}

Should be parsed as:
\begin{lstlisting}
  (((1) .. (10)) by (3))
  (((a[1]) .. (b.3)) by ((1) + (2)))
\end{lstlisting}

Some tricky cases, for example:
\begin{lstlisting}
  1 + 1 .. 10
  - 1 .. 10
\end{lstlisting}

Should be parsed as:
\begin{lstlisting}
  (1 + (1 .. 10))
  (- (1 .. 10))
\end{lstlisting}

The first of which is \textit{illegal} while the second is legal but potentially
\textit{unexpected}. For the first, there is no addition operator defined between an \code{integer}
and an \code{interval}. Second, the unary \code{-} will be applied to the entire range not just the
first operand. Instead, the desired expressions are likely the following:
\begin{lstlisting}
  (1 + 1) .. 10
  (-1) .. 10
\end{lstlisting}

\subsubsection{By Operator}
\label{sssec:interval_byop}
The by operator produces an \code{integer} \code{vector} from an \code{interval}. The \code{integer}
value to the right of the \code{by} operator represents an increment between elements in the
resulting \code{vector}. Values are selected beginning with and including the lower bound of the
\code{interval}. Values after that are obtained by adding the increment to the previous value and
appended to the resulting vector if it is less than or equal to the upper bound of the
\code{interval}. For this reason, increments of zero or less are illegal. Such an increment will
infinitely append values or cause an underflow. For example:

\begin{center}
  \begin{tabular}{|l|l|}
  \hline
  \code{by} expression & integer vector \\
  \hline
  \code{3..6 by 1} & \code{[3, 4, 5, 6]} \\
  \code{3..6 by 2} & \code{[3, 5]}       \\
  \code{3..6 by 3} & \code{[3, 6]}       \\
  \code{3..6 by 4} & \code{[3]}          \\
  \hline
  \end{tabular}
\end{center}

\end{document}
