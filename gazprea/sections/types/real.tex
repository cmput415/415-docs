\documentclass[types.tex]{subfiles}

\begin{document}
A \code{real} is an IEEE 754 32-bit floating point value. A \code{real} can be represented by a
\code{float} in \textit{LLVM IR}.

\subsubsection{Declaration}
\label{sssec:real_decl}
A \code{real} value is declared with the keyword \code{real}.

\subsubsection{null}
\label{sssec:real_null}
\code{null} is \code{0.0} for \code{real}.

\subsubsection{identity}
\label{sssec:real_ident}
\code{identity} is \code{1.0} for \code{real}.

\subsubsection{Literals}
\label{sssec:real_lit}
A \code{real} literal can be specified in several ways. A leading zero is not necessary and can be
inferred from a leading decimal point. For example:
\begin{lstlisting}
  42.0
  4.2
  42.
\end{lstlisting}

A \code{real} literal can also have an attached scientific notation exponent following the mantissa.
Scientific notation multiplies the literal by ${10}^{x}$. For example, $4.2\mathrm{e}-3=4.2
\times10^{-3}$. The scientific notation can also replace the mantissa entirely, following
immediately after the decimal point. Finally, the scientific notation can follow just a pure
\code{integer}, resulting in a real value. For example:
\begin{lstlisting}
  4.2e-1
  4.2e+9
  4.2e5
  42.e-7
  42.e+8
  42.e1
  42e-3
  42e+2
  42e4
\end{lstlisting}

To aid in the readability of large numbers, underscores may be inserted anywhere within or at the
end of a \code{real} literal as a separator. This includes in the integer digits, in the mantissa,
and throughout the scientific notation. For example:
\begin{lstlisting}
  ._____42__
  4_._2_e_-_1_2_
\end{lstlisting}

An underscore may \textbf{NOT} appear at the beginning of a \code{real} literal because then it
would be recognised as an identifier. For example, the following would be identifiers and
\textit{not} \code{real} literals:
\begin{lstlisting}
  _.__4_2____
  ____4_._2
  _1_._e_-2
\end{lstlisting}

\subsubsection{Operations}
\label{sssec:real_ops}
Floating point operations and precedence are equivalent to \hyperref[sssec:integer_ops]{integer
operation and precedence}.

Operations on real numbers should adhere to the \textsf{IEEE 754} spec with regards to the
representation of not-a-number(NaNs), infiity(infs), and zeros. A signaling NaN should cause a
runtime error. Floating point errors and semantics can be guaranteed by using the
\href{https://llvm.org/docs/LangRef.html\#constrained-floating-point-intrinsics}{\textit{LLVM IR}
constrained floating point intrinsics}. The \code{round.towardzero} rounding  mode should be chosen
along with the \code{fpexcept.strict} exception behaviour.

The runtime error cannot be enforced, but, if floating point semantics are not constrained, then
\code{real} values printed after operations may not be identical.

For more information on why this is necessary, look into the
\href{https://llvm.org/docs/LangRef.html\#floatenv}{default \textit{LLVM IR} floating point
environment}.

\end{document}
