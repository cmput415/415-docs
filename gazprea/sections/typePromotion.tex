\documentclass[../gazprea.tex]{subfiles}

\begin{document}
Type promotion is a sub-problem to \nameref{sec:typeCasting} and refers to casts that happen
implicitly without extra syntax such as using \code{as}.

\assertion{Implicit type conversions not found in \nameref{sec:typePromotion} will not be
performed.}{limited-promotion}

\subsection{Scalars}
\label{ssec:typePromotion_scalar}
The only automatic type promotion for scalars is \code{integer} to \code{real}. This promotion is
one way - a \code{real} cannot be automatically converted to \code{integer}.

Automatic type conversion follows this table where N/A means no implicit conversion possible, id
means no conversion necessary, \code{as<toType>(var)} means var of type "From type" is converted to
type "toType" using semantics from \nameref{sec:typeCasting}.
\begin{center}
\begin{tabular}{| c | c | c | c | c | c |}
  \hline
         &           & \multicolumn{4}{c}{To type} \\ \hline
         &           & boolean & character & integer & real          \\ \cline{2-6}
    From & boolean   & id      & N/A       & N/A     & N/A           \\ \cline{2-6}
    type & character & N/A     & id        & N/A     & N/A           \\ \cline{2-6}
         & integer   & N/A     & N/A       & id      & as<real>(var) \\ \cline{2-6}
         & real      & N/A     & N/A       & N/A     & id            \\ \hline
\end{tabular}
\end{center}

\subsection{Scalar to Vector or Matrix}
\label{ssec:typePromotion_stov}
All scalar types can be promoted to \code{vector} or \code{matrix} types that have an internal type
that the scalar can be \hyperref[ssec:typePromotion_scalar]{converted to implicitly}. This can occur
when a \code{vector} or \code{matrix} is used in an operation with a scalar value.

The scalar will be implicitly converted to a \code{vector} or \code{matrix} of equivalent dimensions
and equivalent internal type. For example:
\begin{lstlisting}
  integer i = 1;
  integer vector v = [1, 2, 3, 4, 5];
  integer vector res = v + i;

  var out = std_output();
  res -> out;
\end{lstlisting}

would print the following:
\begin{lstlisting}
  [2 3 4 5 6]
\end{lstlisting}

\subsection{Interval to Vector}
\label{ssec:typePromotion_ivltov}
An \code{interval} can be implicitly converted to an identically-sized \code{vector} of any type that \code{integer}
can be \hyperref[ssec:typePromotion_scalar]{converted to implicitly}. For example:
\begin{lstlisting}
  integer interval i = 1..5;
  integer vector iv[5] = i;
  real vector rv = i;
\end{lstlisting}

\subsection{Tuple to Tuple}
\label{ssec:typePromotion_ttot}
Tuples may be promoted to another type if it has an equal number of internal types and the original
internal types can be implicitly converted to the new internal types. For example:
\begin{lstlisting}
  tuple(integer, integer) int_tup = (1, 2);
  tuple(real, real) real_tup = int_tup;

  tuple(char, integer, boolean[2]) many_tup = ('a', 1, [true, false]);
  tuple(char, real, boolean[2]) other_tup = many_tup;
\end{lstlisting}

\end{document}
