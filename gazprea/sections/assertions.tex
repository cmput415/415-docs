\documentclass[../gazprea.tex]{subfiles}

\begin{document}
\textbf{ALL} input test cases will be valid. It can be a good idea to do error checking for your
own testing and debugging, but it is \textit{not necessary}. If you encounter what you think is
undefined behaviour or think something is ambiguous then \textit{do} make a forum post about it to
clarify.

What does it mean to be valid input? The input must adhere to the specification. The rules below
give more in-depth explanation of specification particulars.
\begin{enumerate}
  \item
    \assertiondest{opened-comments}
    Block comments will be opened. Not opening a block comment will cause ANTLR to encounter a lost
    \code{*/} as well as causing a stream of word tokens starting from where the \code{/*} token
    should be. For example, the following tests would be considered invalid:
    \begin{lstlisting}
      integer i = 0;
      I'm a closed comment, but I'm never opened... */
      integer j = i + 1;
    \end{lstlisting}
  \item
    \assertiondest{closed-comments}
    Block comments will be closed. Not closing a block comment will have ANTLR consume every token
    in the file, rendering the rest of the file useless. For example, the following tests would be
    considered invalid:
    \begin{lstlisting}
      integer i = 0;
      /* I'm an opened comment, but I'm never closed...
      integer j = i + 1;
    \end{lstlisting}
  \item
    \assertiondest{assign-streams}
    The streams constructors \code{std\_output()} and \code{std\_input()} \textit{will not} be used
    in expressions. They must be assigned before use so that \code{stream\_state} can be checked
    later. For example, the following tests would be considered invalid:
    \begin{lstlisting}
      'a' -> std_output();
      character b;
      b <- std_input();
    \end{lstlisting}
  \item
    \assertiondest{tuple-min-fields}
    A \code{tuple} will have at least two internal types. Storing one type would be equivalent to
    storing just the value and the \code{tuple} would be a useless wrapper. Storing zero types would
    be an undefined behaviour with operations on an empty space. For example, the following tests
    would be considered invalid:
    \begin{lstlisting}
      tuple(int);
      tuple();
    \end{lstlisting}
  \item
    \assertiondest{exact-tuple-types}
    The exact size of the internal types of a \code{tuple} will be inferrable at compile time. For
    example, these are invalid:
    \begin{lstlisting}
      tuple(integer vector, int) t1;
      tuple(string, real) t2;
      var t3;
    \end{lstlisting}
  \item
    \assertiondest{tuple-literal-dot}
    Dot notation cannot be applied to \code{tuple} literals. A \code{tuple} literal, to be well
    formed, must have all of its value's types known at compile time
    (\assertionref{exact-tuple-types}) which is only possible if all of the values are known at
    compile time. If the value to be indexed to is known at compile time then there is no need to
    create the \code{tuple}, index the single field, and finally discard the extra values. For
    example, the following tests would be considered invalid:
    \begin{lstlisting}
      integer i = ('a', 1, 3.14).2;
    \end{lstlisting}
    % \assertiondest{vector-length}
    % All vectors will have length $l$ such that $0 \leq l \leq 2^{32}$. Trying to create an index
    % greater than $2^{32} - 1$ will cause overflow and result in a negative number. Indexing with a
    % negative number returns $0$. Therefore, vector locations greater than $2^{32} - 1$ would be
    % inaccessible. For example, the following tests would be considered invalid:
    % \begin{lstlisting}
    %   print((0-1)..2147483647);
    % \end{lstlisting}
    %
    % But the following test is valid because the vector length is still within range:
    % \begin{lstlisting}
    %   print((0-2)..2147483645);
    % \end{lstlisting}
\end{enumerate}

\end{document}
