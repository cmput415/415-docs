\documentclass{article}

\usepackage{hyperref} % Almost certainly will need
\usepackage{fullpage} % Good for making PDFs as well
\usepackage{listings} % Needed to insert code
\usepackage{lstautogobble}

\usepackage[T1]{fontenc}
% This makes it so the web pages don't have indents as most of the time
% they are just annoying
\setlength{\parindent}{0pt}

\usepackage{textcomp}
\lstset{
  upquote=true,
  basicstyle = \ttfamily,
  columns=fullflexible
  escapeinside=||,
  autogobble
}



% This section allows for tex4ht only control statements
% From http://tex.stackexchange.com/questions/93852/what-is-the-correct-way-to-check-for-latex-pdflatex-and-html-in-the-same-latex
\makeatletter
\edef\texforht{TT\noexpand\fi
  \@ifpackageloaded{tex4ht}
    {\noexpand\iftrue}
    {\noexpand\iffalse}}
\makeatother

\newcommand{\code}[1]{\texttt{\textmd{#1}}}

\usepackage[usenames]{color}
\newif\ifComments
\Commentstrue

\ifComments
\newcommand{\todo}[1]{\noindent\textcolor{red}{{#1}}}
\newcommand{\chek}[1]{\noindent\textcolor{red}{Check: {#1}}}
\newcommand{\nelson}[1]{\noindent\textcolor{blue}{Nelson: {#1}}}
\newcommand{\marcus}[1]{\noindent\textcolor{BurntOrange}{Marcus: {#1}}}
\else
\newcommand{\todo}[1]{}
\newcommand{\chek}[1]{}
\newcommand{\nelson}[1]{}
\newcommand{\marcus}[1]{}
\fi

\begin{document}

% This is an SCalc of using a switch to have pdf/html only code
\ifpdf
	\LARGE
	\textbf{SCalc}
	\normalsize
\fi




The goal of this assignment is to implement a compiler for a simple imperative language called \textit{SCalc}. This
compiler will directly generate code for the following three backends:

\begin {itemize}
	\item \textit{x86} assembly
	\item \textit{MIPS} assembly
	\item \textit{ARM} assembly
\end {itemize}

You must also create an \textit{interpreter} for \textit{SCalc}

For the interpreter you will be computing the value of the expressions as you traverse the tree. \textbf{However, when
generating the assembly code you are not allowed to perform the computations in the interpreter} and simply emit
assembly code to print the results. You must create the assembly code to perform the computations that appear in the
input file in the assembly language.

\textit{MIPS} assembly will be tested using \textit{SPIM}

\textit{x86} assembly will be tested using the nasm assembler.

\textit{ARM} assembly will be tested using \textit{qemu-arm}, an arm simulator, and \textit{gcc-arm}

\textbf{You must generate the code using String Templates}. For more information on string templates visit their
\href{https://github.com/antlr/stringtemplate4/blob/master/doc/index.md}{documentation}. Within that
constraint you have a large amount of freedom. You may use any internal representation that you wish. The code that you
generate will be executed to test its correctness. This means that you are allowed to generate any sequence of instructions
you wish, as long as the program yields the correct output.


\section{Language Specification}
	\textit{SCalc} has integer variables, \code{if} statements, loops, prints, and various integer expressions.


	\subsection{Reserved Keywords}

		The following Keywords are reserved in \textit{SCalc}

		\begin {itemize}
			\item{\code{if}}
			\item{\code{fi}}
			\item{\code{loop}}
			\item{\code{pool}}
			\item{\code{int}}
			\item{\code{print}}
		\end {itemize}


	\subsection {Integer Literals}

		In this assignment an integer is a string that contains only the number characters 0-9 with no
		spaces. For the purpose of simplicity all integers in \textbf{input} will be positive. All integers will be
		signed 32 bit integers. Expressions may evaluate to negative values.
		
		Examples of valid integers:

		\begin{lstlisting}
			1
			123
			5234
			01
			10
		\end{lstlisting}
		
		Examples of invalid integers:

		\begin{lstlisting}
			1.0
			one
			1_1
			1o
		\end{lstlisting}
	
	
	\subsection{Identifier}

		For the purpose of this assignment, identifiers are simple. They must start with a character. This character may be followed by
		numbers or characters. An identifier may not be a keyword.
		
		Examples of valid identifiers:

		\begin{lstlisting}
			hello
			h
			h3llo
			Hi
			h3
		\end{lstlisting}

		Examples of invalid identifier:

		\begin{lstlisting}
			3d
			a-bad-variable-name
			no@twitter
			we.don't.like.punctuation
			or_spelling
		\end{lstlisting}
	
	
	\subsection{Expressions}

		An expression is composed of integers, identifiers, and integer mathematical operations.  Valid formats for
		expressions are

		\begin{lstlisting}
			<id>
			<int>
			(<expr>)
			<expr> <op> <expr>
		\end{lstlisting}

		\begin{itemize}
			\item{$\langle$id$\rangle$} is the identifier of a variable
			\item{$\langle$int$\rangle$} is an integer
			\item{$\langle$expr$\rangle$} is an expression
		\end{itemize}
		
		An Example of valid expressions are

		\begin{lstlisting}
			i * 2 * 10 + 4
			2 / 4 * 5
		\end{lstlisting}
		
		\begin{center}
			\begin{tabular}{|c|l|c|l|c|}
				\hline
				\textbf{Class} & \textbf{Operation} & \textbf{Symbol} & \textbf{Usage} &
				\textbf{Associativity} \\
				\hline
				Arithmetic 
				&addition	    & + & \texttt{expr + expr} & left \\
				&subtraction    & - & \texttt{expr - expr} & left \\
				&multiplication & * & \texttt{expr * expr} & left \\
				&division       & / & \texttt{expr / expr} & left \\
				\hline
				Comparison
				&less than      & <  & \texttt{expr < expr}  & left \\
				&greater than   & >  & \texttt{expr > expr}  & left \\
				&is equal       & == & \texttt{expr == expr} & left \\
				&is not equal   & != & \texttt{expr != expr} & left \\
				\hline
			\end{tabular}
		\end{center}
		
		If a comparison expression evaluates to true then it returns 1. If it evaluates to false then it
		return 0. For example:

		\begin{lstlisting}
			print(1==2);
			print(1==1);
		\end{lstlisting}

		should print:

		\begin{lstlisting}
			0
			1
		\end{lstlisting}
		
		Division by zero will not be test in this assignment.
		
		Precedence works as defined in the following table:
		
		\begin{center}
			\begin{tabular}{|c|c|}
			\hline
			\textbf{Precedence} & \textbf{Operations} \\
			\hline
			HIGHER
			& *,/ \\
			& +,- \\
			& <, > \\
			LOWER & ==, != \\
			\hline
			\end{tabular}
		\end{center}
	
	
	\subsection {Statements}
	
		In \textit{SCalc} there are five types of statements:
		
		\begin {itemize}
			\item{declaration}
			\item{assignment}
			\item{conditional}
			\item{loop}
			\item{print}
		\end {itemize}
		
		Each statement ends with a semicolon.  White space is not important in \textit{SCalc}.
	
	
	\subsubsection{Declaration}
		
		A variable in \textit{SCalc} must be declared before being used. A variable declaration in \textit{SCalc} has
		this form:
		
		\begin{lstlisting}
			int <id> = <expr>;
		\end{lstlisting}

		\begin{itemize}
			\item{$\langle$id$\rangle$} is the identifier of a variable.
			\item{$\langle$expr$\rangle$} is an expression
		\end{itemize}
		
		Examples of valid declarations are:
		
		\begin{lstlisting}
			int i = 9;
			int j = 9 * 4 + 10;
			int k = i * j;
		\end{lstlisting}
		
		A Variable may only be declared once in a \textit{SCalc} program. Variable may not be declared without
		initialization. So the following are invalid
		
		\begin{lstlisting}
			int x;
			int x =;
		\end{lstlisting}
	
	
	\subsubsection{Assignment}

		Variable assignment is similar to variable declaration but it allows variables to be reassigned values. Variable
		assignment always has the following form:
		
		\begin{lstlisting}
			<id> = <expr>;
		\end{lstlisting}

		\begin{itemize}
			\item{$\langle$id$\rangle$} is the identifier of a variable.
			\item{$\langle$expr$\rangle$} is an expression
		\end{itemize}
		
		Variables must be declared before being assigned.
	
	
	\subsubsection{Conditional}

		A conditional statement has the following form:
		
		\begin{lstlisting}
			if (<expr>)
				<statement-1>
				<statement-2>
				...
				<statement-n>
			fi;
		\end{lstlisting}

		\begin {itemize}
			\item{$\langle$expr$\rangle$} is an expression. The body of the \code{if} statement is executed if and only
			if this expression evaluates to a non-zero value.
			\item{$\langle$statement-*$\rangle$} are statements
		\end{itemize}
	
	
	\subsubsection{Loop}

		The syntax of a \code{loop} is:
		
		\begin{lstlisting}
			loop (expr)
				<statement-1>
				<statement-2>
				...
				<statement-n>
			pool;
		\end{lstlisting}

		\begin {itemize}
			\item{$\langle$expr$\rangle$} is an expression. The body of the \texttt{loop} statement is repeatedly evaluated as long as
			this expression is non-zero. The expression is evaluated prior to running the body similar to a \textit{C} \texttt{while} loop.
			\item{$\langle$statement-*$\rangle$} are statements
		\end{itemize}
	
	
	\subsubsection{Print}

		In \textit{SCalc} a \texttt{print} statement prints the decimal value of an expression, followed by a newline.
		Print statements have the following form:

		\begin{lstlisting}
			print(<expr>);
		\end{lstlisting}

		\begin{itemize}
			\item{$\langle$expr$\rangle$} is an expression
		\end{itemize}

		An example:

		\begin{lstlisting}
			int i = 0;
			loop (i < 5)
				print(i);
				i = i + 1;
			pool;
		\end{lstlisting}

		Should print

		\begin{lstlisting}
			0
			1
			2
			3
			4
		\end{lstlisting}
	
\section{Back-ends}	
	
	\subsection{MIPS}

		We recommend that you implement variables in the \code{.data} segment of your assembly code using \code{.word} entries. The
		general syntax for MIPS assembly is as follows:

		\begin{lstlisting}
			.data
			_newline: .asciiz "\n"
			var1: .word 0
			var2: .word 0
			...
			
			.text
			main:
			   <your generated code goes here>
			   li   $v0, 10
			   syscall
		\end{lstlisting}
		
		The \href{https://www.cs.tcd.ie/\string~waldroj/itral/spim_ref.html}{spim reference has a table of syscalls}.
		You may use the \texttt{print\_int} syscalls to print integer values, and the \texttt{print\_string} syscall to
		print a newline by defining a string in the \texttt{.data} section called \texttt{\_newline} and print that
		string.
		
		If you save the \textit{MIPS} output as \code{program.s} then you can run it with the command:
		
		\begin{lstlisting}
			spim -file program.s
		\end{lstlisting}
		
		If you wish to debug you may also launch spim with the command:
		
		\begin{lstlisting}
			spim
		\end{lstlisting}
		
		and then at the spim prompt you can load your file with:
		
		\begin{lstlisting}
			load "program.s"
		\end{lstlisting}

		The double quotes are necessary. You can type \texttt{help} to see the commands that spim provides.
	
	
	\subsection{x86}
	
		You should use the Intel syntax for x86, and your compiler's x86 output must work with the nasm assembler.
		x86 output should look something like this:
		
		\begin{lstlisting}
			global main
			
			extern printf
			
			section .data
			var1: DD 0
			var2: DD 0
			...
			
			section .text
			  main:
			    <your generated code goes here>
			    mov eax, 0
			    ret
		\end{lstlisting}
		
		Print will use \code{printf}, which we will link in later to make it easier to implement the \code{print}
		instruction. Printing consists of three steps:

		\begin{enumerate}
			\item push the arguments onto the stack
			\item call \code{printf}
			\item clean up the stack
		\end{enumerate}

		For instance, the following segment of code contains a call to \code{printf}:

		\begin{lstlisting}
			global main
			
			extern printf
			
			section .data
			_format_string: DB "Hello! Here is a number: %d",0xA,0
			
			section .text
			  main:
			    push 7              ; Second argument
			    push _format_string ; First argument (remember stacks are FILO)
			    call printf         ; Make the call to printf
			    add esp, 8          ; Pop the stack, we are done!
			
			    mov eax, 0
			    ret
		\end{lstlisting}
		
		\texttt{0xA} is the \href{http://www.asciitable.com/}{ASCII value of a newline in hexadecimal}. You won't need
		to know more the \textit{x86} calling conventions than what was demonstrated above.
		
		In order to assemble an executable you may run the following commands:
		
		\begin{lstlisting}
			nasm -felf program.s
			gcc program.o -o program -m32
		\end{lstlisting}
		
		Given an assembly file \texttt{program.s} this sequence of commands will produce an executable called
		\texttt{program} that you can run on the lab machines as follows:
		
		\begin{lstlisting}
			./program
		\end{lstlisting}
		
		Try this on the \code{printf} example and make sure that it works!
	
	
	\subsection{ARM}

		The \textit{ARM} assembly output should look something like this:
		
		\begin{lstlisting}
			.arch armv7-a
			.data
			_format_string: .asciz "%d\n"
			var1: .word 0
			var2: .word 0
			...
			
			.text
			.globl main
			main:
			  <your generated code goes here>
			  mov r0, #0
			  mov r1, #1
			  swi 0
		\end{lstlisting}
		
		We will also be using printf with \textit{ARM}. The \textit{ARM} calling convention is different: the first
		argument is passed in r0, and the second argument is passed in r1. The following code demonstrates a call to
		printf in \textit{ARM} assembly:
		
		\begin{lstlisting}
			.arch armv7-a
			.data
			_format_string: .asciz "Hello! Here is a number: %d\n"
			
			.text
			.globl main
			main:
			  push {ip, lr}
			  ldr r0, =_format_string
			  mov r1, #7
			  bl printf
			  mov r0, #0
			  pop {ip, lr}
			
			  mov r0, #0
			  mov r1, #1
			  swi 0
		\end{lstlisting}
		
		Aside from the difference calling convention this code is very similar to the \textit{x86} example.
		
		\textit{ARMv7-A} lacks a division instruction. Therefore, we have to call the subroutine
		\texttt{\_\_aeabi\_idiv} to perform integer division:
		
		\begin{lstlisting}
			.arch armv7-a
			.data
			
			.text
			.globl main
			main:
			  mov r0, #5
			  mov r1, #3
			  bl __aeabi_idiv(PLT)  /* Divide 5 by 3, return the result in r0 */
			
			  mov r1, #1
			  swi 0
		\end{lstlisting}
			
		In order to assemble an executable you may run the following commands:
		
		\begin{lstlisting}
			arm-none-eabi-as -o program.o program.s
			arm-none-eabi-gcc -spec=rdimon.specs -o program program.o
		\end{lstlisting}
		
		Given an assembly file \texttt{program.s} this sequence of commands will produce an executable called
		\texttt{program} that you can run on the lab machines as follows:
		
		\begin{lstlisting}
			qemu-arm ./program
		\end{lstlisting}
		
		Try this on the \texttt{printf} example and make sure that it works!

			
	\subsection{Interpreter}

		You should be able to execute a program without compiling by implementing an interpreter as well. This should
		work similarly to the generator assignment.

\section{Provided Frameworks}

	The following tools have been provided for you to make development and testing easier 

	\subsection{Project Layout}
	
		For the tools provided to work your project should be in the specified layout. You must provide a \texttt{Main.java} that contains your main function. The program should take two command line arguments. The first argument is the mode that your program should run in. The second is the input file. Your program will output the interpreted results of the input or the assembler matching the mode chosen. The modes will be one of the following \texttt{mips}, \texttt{arm}, \texttt{x86} or \texttt{interpret}.
		
		\begin{lstlisting}
			+-- project/
				+-- Makefile
				+-- test_script
				+-- src/
					+-- Main.java	(must contain main function)
					+-- *.g4	(Antlr4 lexer/parser source files)
					+-- *.java	(Java source files)
					+-- *.stg	(StringTemplate string template group files)
				+-- TestFiles/
					+-- Input/
						+-- (testfiles)
						...
					+-- Output/
						+-- (matching output files. Names must match between input test and output test)
						...
		\end{lstlisting}


	\subsection{Makefile}
	
		The \texttt{Makefile} provided is an exact copy of the one that will be used for grading.  Any changes made to
		this makefile will not exist in the one used for grading so as a rule of thumb don't change it. The project must
		be in the specified layout for the makefile to properly work (see \texttt{Project Layout})
		
		The makefile has the following commands:
		
		\begin{itemize}
			\item{\textbf{all}}: Builds all solution files
			\item{\textbf{run}}: Runs the solution (builds solution if necessary)
			\item{\textbf{arm}}: Runs the solution in arm mode (builds solution if necessary)
			\item{\textbf{mips}}: Runs the solution in mips mode (builds solution if necessary)
			\item{\textbf{x86}}: Runs the solution in x86 mode (builds solution if necessary)
			\item{\textbf{interpret}}: Runs the solution in interpret mode (builds solution if necessary)
			\item{\textbf{test}}: Runs testing system against solution (builds solution if necessary)
			\item{\textbf{clean}}: Cleans all generated files including Intellij generated files
			\item{\textbf{submissible}}: Collects files for submission and places them in a tar ball. This file contains
			the files in the format they should be in
		\end{itemize}

	\subsection{scalc\_tester}
	
		This program runs all your test files against their matching outputs. This program is designed to operate in the
		same manor as how the marking script will test solutions.
		
		Help for scalc tester can be found by running with the -h flag:
		
		\begin{lstlisting}
			./test_script -h
		\end{lstlisting}
		
		It by default expects that all input Tests are in \texttt{TestFiles/Input/} and that  all output files are in
		\texttt{TestFiles/Output/}




\section{Tips and Hints}

	\begin{enumerate}
		\item Write tests \textbf{BEFORE} you implement the things they will test. The testing script provided was
		designed to handle failed test cases.  The following command-line flags might be useful when you are running your own tests:
		\begin{description}
			\item[{\tt -a}] turn off stopping on invalid output
			\item[{\tt -s}]  turn off displaying erroneous output 
		\end{description}
		\item The antlr4 visitor method is better than the listener method to create the interpreter.
		\item The MIPS, ARM, and x86 compilers can be built using either method. We suggest that you try the listener method.
		\item A single listener or visitor should be able to handle the x86, MIPS, and ARM code generation. All that should
		change is the string template group file used.
		\item There is no specified syntax guide for string template group files, thus you \textbf{CAN} write those files using
		any style that you chose. However, \textbf{software design practices, which include code legibility, form part of your grade}.
		Consistent style throughout your assignment is important.
		\item This assignment will be extended to build a calculator that handles vectors in the next assignment. For that assignment
		you will need to do type checking. Therefore you are advised to:
		\begin {enumerate}
			\item Read that assignment now
			\item Include type checking in this solution, even though you are only
			required to handle integers in this assignment.
		\end {enumerate}
	\end{enumerate}

\end{document}
